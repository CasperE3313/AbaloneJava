package abalone;

public class ComputerPlayer extends Player {

    private Strategy strategy;
    private Edge edge = new Edge();

    /**
     * The constructor of ComputerPlayer.
     * 
     * @requires marble != null, strategy != null
     * @param marble Marble
     * @param strategy either smart or naive
     */
    public ComputerPlayer(Marble marble, Strategy strategy) {
        super(strategy.getName(), marble, 2);
        this.strategy = strategy;
    }

    /**
     * This methods returns the strategy used by the ComputerPlayer.
     * 
     * @return strategy of this ComputerPlayer
     */
    public Strategy getStrategy() {
        return strategy;
    }

    /**
     * This method determines a move and checks if the move is a valid move.
     * 
     * @requires board != null, opponent != null, choice != null
     * @param board Board
     * @param opponent Player
     * @param choice String
     * @ensures a move generated by the strategy is returned
     * @return String which is the validated choice of the ComputerPlayer
     */
    @Override
    public String determineMove(Board board, Player opponent, String choice) {
        choice = strategy.determineMove(board, this, opponent);
        String[] arr = choice.split(",");
        boolean valid = false;
        while (!valid) {
            if (arr.length == 3) {
                String crd1 = arr[0];
                String crd2 = arr[1];
                String direction = arr[2];
                if (board.isField(crd1) && board.isField(crd2) && neighbor.isDirection(direction)) {
                    Move move = new Move(board, this);
                    int marbles;
                    marbles = move.howManyMarbles(crd1, crd2);
                    if (marbles == 1) {
                        if (board.getField(crd1) == this.getMarble()) {
                            if (!edge.isEdgeField(crd1, direction)) {
                                if (board.getField(neighbor.getNeighbor(crd1, direction)) == Marble.o) {
                                    valid = true;
                                    break;
                                }
                            }
                        }
                    } else if (marbles == 2) {
                        if (move.isLineMove(crd1, crd2, direction)) {
                            if (move.isPushOff(crd1, crd2, direction)) {
                                valid = true;
                                break;
                            } else if (move.isSumito(crd1, crd2, direction)) {
                                valid = true;
                                break;
                            } else {
                                if (board.getField(crd1) == this.getMarble()
                                        && board.getField(crd2) == this.getMarble()) {
                                    if (!edge.isEdgeField(move.getFrontMarble(crd1, crd2, direction), direction)
                                            && board.getField(
                                                    neighbor.getNeighbor(move.getFrontMarble(crd1, crd2, direction),
                                                            direction)) == Marble.o) {
                                        valid = true;
                                        break;
                                    }
                                }
                            }
                        } else {
                            if (board.getField(crd1) == this.getMarble() && board.getField(crd2) == this.getMarble()) {
                                if (!edge.isEdgeField(crd1, direction) & !edge.isEdgeField(crd2, direction)) {
                                    if (board.getField(neighbor.getNeighbor(crd1, direction)) == Marble.o
                                            && board.getField(neighbor.getNeighbor(crd2, direction)) == Marble.o) {
                                        valid = true;
                                        break;
                                    }
                                }
                            }
                        }
                    } else if (marbles == 3) {
                        if (move.isLineMove(crd1, crd2, direction)) {
                            if (move.isPushOff(crd1, crd2, direction)) {
                                valid = true;
                                break;
                            } else if (move.isSumito(crd1, crd2, direction)) {
                                valid = true;
                                break;
                            } else {
                                if (!edge.isEdgeField(move.getFrontMarble(crd1, crd2, direction), direction)
                                        && board.getField(neighbor.getNeighbor(
                                                move.getFrontMarble(crd1, crd2, direction), direction)) == Marble.o) {
                                    valid = true;
                                    break;
                                }
                            }
                        } else {
                            if (!edge.isEdgeField(crd1, direction) && !edge.isEdgeField(crd2, direction)
                                    && !edge.isEdgeField(neighbor.getSharedNeighbor(crd1, crd2), direction)) {
                                if (board.getField(neighbor.getNeighbor(crd1, direction)) == Marble.o
                                        && board.getField(neighbor.getNeighbor(crd2, direction)) == Marble.o
                                        && board.getField(neighbor.getNeighbor(neighbor.getSharedNeighbor(crd1, crd2),
                                                direction)) == Marble.o) {
                                    valid = true;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            choice = strategy.determineMove(board, this, opponent);
            arr = choice.split(",");
            valid = false;
        }
        System.out.println(choice);
        return choice;
    }
}
